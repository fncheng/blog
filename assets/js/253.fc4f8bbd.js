(window.webpackJsonp=window.webpackJsonp||[]).push([[253],{542:function(t,a,o){"use strict";o.r(a);var r=o(8),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("strong",[t._v("Table of Contents")]),t._v(" "),a("em",[t._v("generated with "),a("a",{attrs:{href:"https://github.com/thlorenz/doctoc",target:"_blank",rel:"noopener noreferrer"}},[t._v("DocToc"),a("OutboundLink")],1)])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#shadow-dom%E4%B8%8E%E8%99%9A%E6%8B%9Fdom"}},[t._v("Shadow DOM与虚拟DOM")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#shadow-dom"}},[a("strong",[t._v("Shadow DOM")])])]),t._v(" "),a("li",[a("a",{attrs:{href:"#virtual-dom"}},[a("strong",[t._v("Virtual DOM")])])])])])]),t._v(" "),a("h2",{attrs:{id:"shadow-dom与虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shadow-dom与虚拟dom"}},[t._v("#")]),t._v(" Shadow DOM与虚拟DOM")]),t._v(" "),a("p",[t._v("可以想象成我们在 Vue 或者 React 中使用的一个个组件，是一种将 HTML 结构、Style 封装起来的结构。我们熟悉的 "),a("code",[t._v("video")]),t._v(" 标签，其实就是 "),a("code",[t._v("Shadow DOM")]),t._v(" 的封装。")]),t._v(" "),a("h3",{attrs:{id:"shadow-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shadow-dom"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Shadow DOM")])]),t._v(" "),a("p",[t._v("Shadow DOM是浏览器提供的一个可以允许将隐藏的DOM树添加到常规的DOM树中——它以shadow root为起始根节点，在这个根节点的下方，可以是任意元素，和普通的DOM元素一样。")]),t._v(" "),a("h3",{attrs:{id:"virtual-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Virtual DOM")])]),t._v(" "),a("p",[t._v("虚拟DOM是由js实现的避免DOM树频繁更新，通过js的对象模拟DOM中的节点，然后通过特定的render方法将它渲染成真实的节点，数据更新时，渲染得到新的 Virtual DOM，与上一次得到的 Virtual DOM 进行 diff，得到所有需要在 DOM 上进行的变更，然后在 patch 过程中应用到 DOM 上实现UI的同步更新。"),a("strong",[t._v("本质上是JavaScript对象")])]),t._v(" "),a("p",[t._v("是用 JS 对象描述 DOM 节点的数据。")])])}),[],!1,null,null,null);a.default=s.exports}}]);