(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{452:function(e,_,v){"use strict";v.r(_);var t=v(8),o=Object(t.a)({},(function(){var e=this,_=e._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"什么是flux架构❓"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是flux架构❓"}},[e._v("#")]),e._v(" 什么是Flux架构❓")]),e._v(" "),_("h3",{attrs:{id:"flux将应用分成四个部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#flux将应用分成四个部分"}},[e._v("#")]),e._v(" Flux将应用分成四个部分")]),e._v(" "),_("ul",[_("li",[e._v("View： 视图层")]),e._v(" "),_("li",[e._v("Action（动作）：视图层发出的消息（比如mouseClick）")]),e._v(" "),_("li",[e._v("Dispatcher（派发器）：用来接收Actions、执行回调函数")]),e._v(" "),_("li",[e._v("Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面")])]),e._v(" "),_("p",[_("img",{attrs:{src:"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png",alt:""}})]),e._v(" "),_("h3",{attrs:{id:"flux-数据单向流动"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#flux-数据单向流动"}},[e._v("#")]),e._v(" Flux 数据单向流动")]),e._v(" "),_("ol",[_("li",[e._v("用户访问 View")]),e._v(" "),_("li",[e._v("View 发出用户的 Action")]),e._v(" "),_("li",[e._v("Dispatcher 收到 Action，要求 Store 进行相应的更新")]),e._v(" "),_("li",[e._v('Store 更新后，发出一个"change"事件')]),e._v(" "),_("li",[e._v('View 收到"change"事件后，更新页面')])]),e._v(" "),_("h2",{attrs:{id:"flux思想"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#flux思想"}},[e._v("#")]),e._v(" Flux思想")]),e._v(" "),_("p",[_("code",[e._v("Flux")]),e._v(" 是一种前端架构模式，旨在解决React中数据流管理的问题。该架构提出了严格的单向数据流的概念，将整个应用分为四层："),_("code",[e._v("View")]),e._v("、"),_("code",[e._v("Action")]),e._v("、"),_("code",[e._v("Dispatcher")]),e._v("、"),_("code",[e._v("Store")]),e._v("。")]),e._v(" "),_("p",[e._v("其中 "),_("code",[e._v("Store")]),e._v(" 层用于存储应用程序状态，并实现状态的变化逻辑。在 "),_("code",[e._v("Flux")]),e._v(" 中，每次状态的变化由 "),_("code",[e._v("Action")]),e._v(" 触发，然后 "),_("code",[e._v("Action")]),e._v(" 会把更新的状态信息打包成一个 "),_("code",[e._v("Action Payload")]),e._v(" 对象再向 "),_("code",[e._v("Dispatcher")]),e._v(" 分发。"),_("code",[e._v("Dispatcher")]),e._v(" 会通知所有的 "),_("code",[e._v("Store")]),e._v("，告诉它们有一个新的 "),_("code",[e._v("Action")]),e._v(" 发生了，让它们可以对这个 "),_("code",[e._v("Action")]),e._v(" 做出响应。当一个 "),_("code",[e._v("Store")]),e._v(" 接收到一个 "),_("code",[e._v("Action")]),e._v(" 后，就需要根据 "),_("code",[e._v("Action")]),e._v(" 的类型来改变自身的状态，这就是 "),_("code",[e._v("Reducer")]),e._v(" 的任务。最后，所有 "),_("code",[e._v("Store")]),e._v(" 会把新的状态信息以 "),_("code",[e._v("change")]),e._v(" 事件的形式向 "),_("code",[e._v("View")]),e._v(" 层发布，这样 "),_("code",[e._v("View")]),e._v(" 层就可以通过监听 "),_("code",[e._v("change")]),e._v(" 事件来更新自己的视图。")]),e._v(" "),_("p",[e._v("可以看出，"),_("code",[e._v("Action")]),e._v(" 和 "),_("code",[e._v("Reducer")]),e._v(" 是 "),_("code",[e._v("Flux")]),e._v(" 架构中的两个非常核心的概念，其中 "),_("code",[e._v("Action")]),e._v(" 用于描述状态的变化，而 "),_("code",[e._v("Reducer")]),e._v(" 则用于根据 "),_("code",[e._v("Action")]),e._v(" 的类型来更新相应的 "),_("code",[e._v("Store")]),e._v(" 的状态。因此，可以说 "),_("code",[e._v("Reducer")]),e._v(" 的思想是 "),_("code",[e._v("Flux")]),e._v(" 架构的核心之一。")]),e._v(" "),_("p",[e._v("需要注意的是，"),_("code",[e._v("Reducer")]),e._v(" 的思想并不限于 "),_("code",[e._v("Flux")]),e._v(" 架构中，它同样适用于其他前端框架如 Vue、Angular 等。"),_("code",[e._v("Reducer")]),e._v(" 的核心思想是根据 "),_("code",[e._v("Action")]),e._v(" 的类型来实现状态变化的逻辑，这个思想在前后端系统中都有非常广泛的应用。")]),e._v(" "),_("p",[e._v("Flux架构具体内容可以看"),_("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/01/flux.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("这篇文章"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("实现一个Flux应用")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://codesandbox.io/s/vue2-flux-09gjd?file=/src/dispatcher/AppDispatcher.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("CodeSandBox"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("a",{attrs:{href:"https://www.npmjs.com/package/flux",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flux-npm"),_("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=o.exports}}]);