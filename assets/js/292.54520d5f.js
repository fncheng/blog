(window.webpackJsonp=window.webpackJsonp||[]).push([[292],{583:function(e,v,_){"use strict";_.r(v);var t=_(8),r=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"vue的re-render机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue的re-render机制"}},[e._v("#")]),e._v(" Vue的re-render机制")]),e._v(" "),v("p",[e._v("Vue 的 "),v("strong",[e._v("re-render")]),e._v(" 过程会导致模板字符串（包括在 "),v("code",[e._v("template")]),e._v(" 中的绑定）重新执行。原因是，Vue 在每次数据更新时，会重新计算并渲染模板，进而触发模板内的所有动态绑定的更新。")]),e._v(" "),v("p",[e._v("详细过程：")]),e._v(" "),v("ol",[v("li",[v("strong",[e._v("数据变化")]),e._v("：当响应式数据发生变化时，Vue 会触发组件的重新渲染过程。")]),e._v(" "),v("li",[v("strong",[e._v("重新计算渲染函数")]),e._v("：Vue 会重新计算模板对应的渲染函数（"),v("code",[e._v("render")]),e._v("）并执行。对于模板字符串中的绑定（如 "),v("code",[e._v(e._s(e.variable))]),e._v(" 或 "),v("code",[e._v(':property="value"')]),e._v(" 等），这些绑定会在渲染过程中重新计算。")]),e._v(" "),v("li",[v("strong",[e._v("更新虚拟 DOM")]),e._v("：渲染函数执行时，所有动态的数据绑定都会重新求值，并生成新的虚拟 DOM（VNode）。")]),e._v(" "),v("li",[v("strong",[e._v("比较并更新 DOM")]),e._v("：通过"),v("code",[e._v("diff")]),e._v(" 算法，Vue 会将新的虚拟 DOM 与旧的虚拟 DOM 进行比较，找出差异并应用更新到真实 DOM 上。")])]),e._v(" "),v("p",[e._v("re-render会触发"),v("code",[e._v("render")]),e._v(" 函数重新执行，但并不会重新声明 "),v("code",[e._v("ref")]),e._v(" 或 "),v("code",[e._v("reactive")]),e._v(" 等响应式变量。")]),e._v(" "),v("h2",{attrs:{id:"react的re-render"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react的re-render"}},[e._v("#")]),e._v(" React的re-render")]),e._v(" "),v("p",[e._v("React的函数组件都是一个个函数，当组件重新渲染时，函数会重新执行。")]),e._v(" "),v("p",[e._v("但"),v("code",[e._v("useState")]),e._v(" 定义的 state 不会重新定义，这是 React 的特性之一")]),e._v(" "),v("p",[v("code",[e._v("useState")]),e._v(" 是一个 Hook，用于在函数组件中声明状态。即使组件函数重新执行，"),v("code",[e._v("useState")]),e._v(" 中的 "),v("strong",[e._v("state 值是 React 内部维护的")]),e._v("，它不会因为函数重新执行而被重新初始化。")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("原理")]),e._v("： React 通过一个「Hook 调用栈」来记住每次调用 "),v("code",[e._v("useState")]),e._v(" 的顺序和对应的值。即使函数重新执行，React 依然能找到正确的状态值。")])]),e._v(" "),v("p",[e._v("当你调用 "),v("code",[e._v("useState(initialValue)")]),e._v(" 时：")]),e._v(" "),v("ul",[v("li",[e._v("初次渲染时，React 使用 "),v("code",[e._v("initialValue")]),e._v(" 来初始化 state。")]),e._v(" "),v("li",[e._v("后续渲染时，React 不会再次使用 "),v("code",[e._v("initialValue")]),e._v("，而是返回之前存储的 state 值。")])]),e._v(" "),v("p",[e._v("React组件渲染流程是从根组件开始的，但更新是基于变更的组件树中受影响的部分。")]),e._v(" "),v("p",[e._v("即我们常说的React组件渲染是自上而下的，父组件re-render会触发子组件的re-render（除非通过memo等手段优化）")])])}),[],!1,null,null,null);v.default=r.exports}}]);