## 通过createBrowserRouter创建路由

**1. 创建路由（routes.tsx）**

```tsx
import { createBrowserRouter } from 'react-router-dom';
import Home from './Home';
import About from './About';
import App from './App';

export const router = createBrowserRouter([
  {
    path: '/',
    element: <App />,  // App 作为顶级路由
    children: [
      {
        path: 'home',
        element: <Home />,
      },
      {
        path: 'about',
        element: <About />,
      },
    ],
  },
]);
```

**2. 使用 RouterProvider 包裹应用（main.tsx 或 index.tsx）**

```tsx
import React from 'react';
import ReactDOM from 'react-dom';
import { RouterProvider } from 'react-router-dom';
import { router } from './routes';

ReactDOM.render(
  <RouterProvider router={router} />,
  document.getElementById('root')
);
```

## React的beforeEach

Vue的路由守卫beforeEach在页面路由发生变化时便会执行。
React没有提供类似的Api，但是AppApp 组件在每次路由变化时都会被执行。于是我们可以通过 React Router 的一些功能来实现类似的效果。

使用 useEffect 和 useLocation 实现路由守卫

```tsx
import { useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';

const App = () => {
  const navigate = useNavigate();
  const location = useLocation();

  useEffect(() => {
    // 类似于 beforeEach 的效果
    const handleRouteChange = () => {
      // 这里可以执行路由守卫逻辑，比如权限验证
      const isAuthenticated = false; // 假设为未登录状态
      if (!isAuthenticated && location.pathname !== '/login') {
        navigate('/login'); // 如果没有登录就跳转到登录页
      }
    };
    handleRouteChange(); // 路由变化时触发
    // 如果有条件，可以在此加入监听路由变化的逻辑
  }, [location.pathname]);
return <App />;
```

当我们满怀欣喜的以为就能大功告成时，却发现控制台报错了：
`Uncaught Error: useLocation() may be used only in the context of a <Router> component.`

原来这是因为 React Router提供的hooks `useLocation`,`useNavigate`必须在Router组件的内部使用

要解决这个问题，你需要确保 App 组件在 Router 组件的包裹下运行

在index.tsx中包裹
```tsx
ReactDOM.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById('root')
);
```

但是如果使用的是createBrowserRouter呢？

那我们就需要将App组件作为根路由

routes.tsx

```tsx
export const routes: RouteConfig[] = [
    {
        path: "/login",
        element: (
            <Login />
        ),
        meta: {
            name: "登录页",
        },
    },
    {
        path: "/",
        errorElement: <Error />,
        element: <App />,
        children: [
            { path: "", element: <Home /> },
            {
                path: "about1",
                element: <About1 />,
            },
            {
                id: "user",
                path: "about",
                element: <About />,
                meta: { requireAuth: true },
                loader: userLoader,
            },
            { path: "test", element: <Test /> },
        ],
    },
    { path: "*", element: <NotFound /> },
];
```

App.tsx

```tsx
export function App1() {
    const [isLogin, setLogin] = useState<boolean>(() => {
        const storeValue = localStorage.getItem("isLogin");
        return storeValue ? JSON.parse(storeValue) : false;
    });

    const location = useLocation();
    const navigate = useNavigate();
    console.log('location: ', location);

    const handleRouteChange = () => {
        console.log("------全局路由守卫------", isLogin);
        if (!isLogin && location.pathname !== "/login") {
            navigate("/login");
        }
    };

    useEffect(() => {
        handleRouteChange();
    }, [location.pathname]);

    return <AppLayout />;
}
```

index.tsx

```tsx
root.render(
    <Suspense fallback={<Loading />}>
        <RouterProvider router={router} />
    </Suspense>
);
```



### 如果我同时还需要全局Context怎么办

将ContextProvider组件放在最外面

首先创建Context并提供Provider组件

```tsx
interface IGlobalContext {
  isLogin: boolean
  setLogin: React.Dispatch<React.SetStateAction<boolean>>
}

export const GlobalContext = createContext<IGlobalContext>({
  isLogin: JSON.parse(localStorage.getItem('isLogin') || 'false'),
  setLogin: () => {}
})

// 创建 Provider 组件
interface GlobalProviderProps {
  children: JSX.Element;
}
export const GlobalProvider: React.FC<GlobalProviderProps> = ({ children }) => {
  const [isLogin, setLogin] = useState<boolean>(() => {
    const storeValue = localStorage.getItem("isLogin");
    return storeValue ? JSON.parse(storeValue) : false;
  });

  return (
    <GlobalContext.Provider value={{ isLogin, setLogin }}>
        {children}
    </GlobalContext.Provider>);
};

// 创建自定义 hook，便于使用
export const useGlobalContext = () => {
  const context = useContext(GlobalContext);
  if (!context) {
    throw new Error('useGlobalContext must be used within a GlobalProvider');
  }
  return context;
};
```

在index.tsx中最外层用 GlobalProvider 包裹

```tsx
root.render(
    <GlobalProvider>
        <Suspense fallback={<Loading />}>
            <RouterProvider router={router} />
        </Suspense>
    </GlobalProvider>
);
```

