---
title: React组件通信
---



## props.children

props.children是组件的所有子节点

```jsx
<MiddleComponent name={"zs"} age={20}>
   31321
</MiddleComponent>

class MiddleComponent extends React.Component {
  constructor(props) {
    super(props);
    console.log(props); // {name: "zs", age: 20, children: "31321"}
  }
}
```



## Context

> 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。
>
> Provider 接收一个 `value` 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。

```tsx
interface ThemeContext {
  color: 'red' | 'blue'
}

export const themeContext: Context<ThemeContext> = createContext<ThemeContext>({
  color: 'red'
})

export default function App() {
  return (
  	<themeContext.Provider value={{ color: 'blue' }}>
        <Topics />
    </themeContext.Provider>
  )
}

// in Topic
import { themeContext } from './App'

const Topics: React.FC = () => {
  return <themeContext.Consumer>
    {({ color }) => <h3>{color}</h3>}
  </themeContext.Consumer>
}
```

使用useContext能够更简单

```tsx
import { useContext } from 'react'
import { themeContext } from './App'

const Topics: React.FC = () => {
  const theme = useContext(themeContext)
  return <h3>{theme.color}</h3>
}
```



**App.jsx**

```jsx
import { AppContext, context } from "./context";

export default function App() {
  return (
    <AppContext.Provider value={context}>
      <div className="App">
        <Main />
        <Child />
      </div>
    </AppContext.Provider>
  );
}

function Child() {
  return (
    <div>
      <div>345</div>
      <AppContext.Consumer>{(val) => val.username}</AppContext.Consumer>
    </div>
  );
}
```

**context.js**

```js
import React from "react";
export const AppContext = React.createContext({});
export const context = {
  username: "ls"
};
```



### context与函数组件使用

useContext

```jsx
export const MyContext = React.createContext({
  name: "zs",
  age: 22
});

export default function App() {
  return (
    <MyContext.Provider value={{ name: "zsss", age: 30 }}>
      <div className="App">
        <Main />
        <Child />
      </div>
    </MyContext.Provider>
  );
}

function Child() {
  const ctx = useContext(MyContext);
  console.log(ctx.age);
  return (
    <>
      <div>{ctx.name}</div>
    </>
  );
}
```

## context作为全局状态以及修改context

context可以用来作为全局状态，不过context本身是只读的。

不过我们可以通过Context.Provider 的value属性来达到修改context的目的， value 属性是用来传递一个值给所有被这个 Context 包裹的组件的。

```tsx
export const CountContext = createContext({ count: 0 })
export default function App() {
  const [count, setCount] = useState(0)
  
  return (
    <CountContext.Provider value={{ count }}>
    	<Topics />
    </CountContext.Provider>
  )
}

// in Topics
import { CountContext } from './App'

const Topics: React.FC = () => {
  return <CountContext.Consumer>{(ctx) => ctx.count}</CountContext.Consumer>
}

// 或者使用useContext
const Topics: React.FC = () => {
  const ctx = useContext(CountContext)
  return <h3>{ctx.count}</h3>
}
```

如果想在子组件内修改context，可以传一个方法用于修改

```tsx
export default function App() {
  const context = useContext(CountContext)
  const [count, setCount] = useState(context.count)
  context.incrementCount = () => {
    setCount(count + 1)
  }
  
  return (
    <CountContext.Provider value={{ count, incrementCount }}>
    	<Topics />
    </CountContext.Provider>
  )
}
```



### 通过useReducer来配合Context

```tsx
interface State {
  count: number
}
type Action = { type: 'increment' } | { type: 'decrement' } | { type: 'reset' }
interface ContextType {
  state: State
  dispatch: React.Dispatch<Action>
}

export const MyContext = createContext<ContextType>({
  state: { count: 0 },
  dispatch: () => {}
})
const myReducer = (state: State, action: Action) => {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 }
  }
}
export default function App() {
  const [state, dispatch] = useReducer(myReducer, { count: 100 })
  return (
  	<MyContext.Provider value={{ state, dispatch }}>
      <About />
    </MyContext.Provider>
  )
}

// in About
const About: React.FC = () => {
  const {state,dispatch} = useContext(MyContext)
  console.log('ctx: ', ctx)
  // return <CountContext.Consumer>{(ctx) => ctx.count}</CountContext.Consumer>
  return (
    <>
      <button onClick={() => dispatch({ type: 'increment' })}>reducer</button>
      <h3>{state.count}</h3>
    </>
  )
}
```





## 函数调用向上传递

```jsx
export default function Father() {
  let [num, setNum] = useState(0)
  return (
    <>
      <div num={num}>向上传递展示的值: {num}</div>
      <button onClick={() => setNum(++num)}>向下传递++</button>
      <Son
        son-num={num}
        onMy={(val) => {
          console.log('son', val)
          setNum(num - val)
        }}
      ></Son>
    </>
  )
}

function Son(props) {
  console.log('props: ', props)
  const { onMy } = props
  const [sonState] = useState(2)
  return (
    <>
      <div>向下传递展示的值: {props['son-num']}</div>
      <button onClick={() => onMy(sonState)}>向上传递--</button>
    </>
  )
}
```

在React中只有通过setState修改的数据，视图才会实时更新



### React子传父

React中是单向数据流，数据只能从父组件通过属性的方式传给其子组件



报错

Uncaught Invariant Violation：太多的重新渲染

https://www.jianshu.com/p/bf197fba2fa5
