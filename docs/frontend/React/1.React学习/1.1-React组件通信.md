---
title: React组件通信
---



## props.children

props.children是组件的所有子节点

```jsx
<MiddleComponent name={"zs"} age={20}>
   31321
</MiddleComponent>

class MiddleComponent extends React.Component {
  constructor(props) {
    super(props);
    console.log(props); // {name: "zs", age: 20, children: "31321"}
  }
}
```



## Context

> 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。
>
> Provider 接收一个 `value` 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。

```tsx
interface ThemeContext {
  color: 'red' | 'blue'
}

export const themeContext: Context<ThemeContext> = createContext<ThemeContext>({
  color: 'red'
})

export default function App() {
  return (
  	<themeContext.Provider value={{ color: 'blue' }}>
        <Topics />
    </themeContext.Provider>
  )
}

// in Topic
import { themeContext } from './App'

const Topics: React.FC = () => {
  return <themeContext.Consumer>
    {({ color }) => <h3>{color}</h3>}
  </themeContext.Consumer>
}
```

使用useContext能够更简单

```tsx
import { useContext } from 'react'
import { themeContext } from './App'

const Topics: React.FC = () => {
  const theme = useContext(themeContext)
  return <h3>{theme.color}</h3>
}
```



**App.jsx**

```jsx
import { AppContext, context } from "./context";

export default function App() {
  return (
    <AppContext.Provider value={context}>
      <div className="App">
        <Main />
        <Child />
      </div>
    </AppContext.Provider>
  );
}

function Child() {
  return (
    <div>
      <div>345</div>
      <AppContext.Consumer>{(val) => val.username}</AppContext.Consumer>
    </div>
  );
}
```

**context.js**

```js
import React from "react";
export const AppContext = React.createContext({});
export const context = {
  username: "ls"
};
```



### context与函数组件使用

useContext

```jsx
export const MyContext = React.createContext({
  name: "zs",
  age: 22
});

export default function App() {
  return (
    <MyContext.Provider value={{ name: "zsss", age: 30 }}>
      <div className="App">
        <Main />
        <Child />
      </div>
    </MyContext.Provider>
  );
}

function Child() {
  const ctx = useContext(MyContext);
  console.log(ctx.age);
  return (
    <>
      <div>{ctx.name}</div>
    </>
  );
}
```





## 函数调用向上传递

```jsx
export default function Father() {
  let [num, setNum] = useState(0)
  return (
    <>
      <div num={num}>向上传递展示的值: {num}</div>
      <button onClick={() => setNum(++num)}>向下传递++</button>
      <Son
        son-num={num}
        onMy={(val) => {
          console.log('son', val)
          setNum(num - val)
        }}
      ></Son>
    </>
  )
}

function Son(props) {
  console.log('props: ', props)
  const { onMy } = props
  const [sonState] = useState(2)
  return (
    <>
      <div>向下传递展示的值: {props['son-num']}</div>
      <button onClick={() => onMy(sonState)}>向上传递--</button>
    </>
  )
}
```

在React中只有通过setState修改的数据，视图才会实时更新



### React子传父

React中是单向数据流，数据只能从父组件通过属性的方式传给其子组件



报错

Uncaught Invariant Violation：太多的重新渲染

https://www.jianshu.com/p/bf197fba2fa5
